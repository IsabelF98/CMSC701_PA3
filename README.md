## CMSC701 Programming Assignment 3: Evaluating two different AMQsIsabel FernadezMay 11, 2023### Part 1: Empirical evaluation of the bloom filter***All code for part 1 can be found in `part1_bloom_filter.py`. To implement the bloom filter I used the [Python bloom-filter package](https://pypi.org/project/bloom-filter/).The code runs through the complete analysis creating $K$ and $K'$, building the bloom filter for different error rates, finding the false positive rate for each run,computing the run time to query $K'$, and finding the memory of each bloom filter. The false positive rates are saved as a CSV file (one for each error rate).The CPU time is displayed in 4 plots, 1 for each error rates given the different ratios of $K$ to $K'$ and 1 of the average time for the different error rates.And lastly the memory is displayed as a plot of the size of $K$ vs. memory in bits.### Part 2: Empirical evaluation of a minimal perfect hash function (MPHF)***All code for part 2 can be found in `part2_mphf.py`. To implement the MPHF I used the [Python bbhash package](https://pypi.org/project/bbhash/).The code runs through the complete analysis creating $K$ and $K'$, building the MPHF, finding the false positive rate for each run, computing the run time to query $K'$, and finding the memory of each MPHF. The false positive rates are saved as a CSV file . The CPU time is displayed as the size of $K$ vs. time for each ration of $K$ to $K'$. And lastly the memory is displayed as a plot of the size of $K$ vs. memory in bits.### Part 3: Augment the MPHF with a “fingerprint array”***All code for part 2 can be found in `part3_MPHF_fingerprint.py`. To implement the secondery hash function I used the [Python xxhash package](https://pypi.org/project/xxhash/).The code runs through the complete analysis creating $K$ and $K'$, building the MPHF with the fingerprint array for different error rates (i.e. $b$ value), finding the false positive rate for each run, computing the run time to query $K'$, and finding the memory of each bloom filter. The false positive rates are saved as a CSV file (one for each error rate). The CPU time is displayed in 4 plots, 1 for each error rates given the different ratios of $K$ to $K'$ and 1 of the average time for the different error rates. And lastly the memory is displayed as a plot of the size of $K$ vs. memory in bits.### Utils***All additional code to aid parts 1, 2, and 3 can be found in `utils.py`. This code inculed the following functions:* `unique_str_list`: This function creates a list of unique strings of length $n$ where each string is of lenth $d$ and comprised of characters in the list letters.* `string_lists`: Generates list $K$ and $K'$ where $K$ is a list of $k$-mers and $K'$ is a list of the same $k$-mers but a given ratio are relpaced with different $k$-mers. ($k = 32$)* `unique_int_list`: This function creates a list of unique $d$-digit integers of length $n$.* `int_lists`: Generates list $K$ and $K'$ where $K$ is a list of  unique 10-digit integers and $K'$ is a list of the same integers but a given ratio are relpaced with 8-digit integers.* `str_int_dict`: Generates dictionaries $K$ and $K'$ where $K$ is a dictionary of size $n$ with values of unique $k$-mers ($k=32$) and keys of unique 10-digit integers and $K'$ is a dictionary of the same keys and values but a given ratio are relpaced with different $k$-mers as values and $8$-digit integers as keys.